<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8"/>
    <title>Compression, décompression et images protégées (offline)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Optionnel: si Internet est disponible, ces CDN activeront le vrai ZIP -->
    <script>
      (function(){
        var s1=document.createElement('script'); s1.src='https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        var s2=document.createElement('script'); s2.src='https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js';
        s1.onerror=s2.onerror=function(){ / silencieux si offline / };
        document.head.appendChild(s1); document.head.appendChild(s2);
      })();
    </script>
    <style>
      :root { --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#9ca3af; --primary:#22c55e; --secondary:#334155; }
      * { box-sizing: border-box; }
      body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: linear-gradient(135deg,#0f172a,#1f2937); color: var(--text); }
      .container { max-width: 900px; margin: 32px auto; background: var(--card); padding: 24px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
      h1,h2 { margin-top:0; color:#fff; }
      section { margin-top:24px; padding-top:12px; border-top:1px solid #222; }
      label { display:block; margin:12px 0 6px; color:var(--muted); }
      input[type="file"], input[type="password"], input[type="text"] { width:100%; background:#0b1220; color:var(--text); border:1px solid #1f2937; border-radius:8px; padding:10px; }
      .btn { display:inline-block; margin-top:14px; padding:10px 16px; background:var(--primary); color:#0b1220; border:none; border-radius:8px; cursor:pointer; font-weight:600; text-decoration:none; }
      .btn:hover { filter:brightness(1.1); }
      .btn-secondary { background:var(--secondary); color:#fff; }
      .note { color:var(--muted); font-size:0.95rem; }
      .card { background:#0b1220; border:1px solid #1f2937; border-radius:8px; padding:12px; margin-top:12px; }
      ul { padding-left:20px; }
      img { max-width:100%; height:auto; border-radius:8px; }
      .id-box { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#0b1220; border:1px dashed #334155; border-radius:8px; padding:10px; margin-top:8px; color:#93c5fd; word-break:break-all; }
      .warn { background:#3b82f61a; border:1px solid #3b82f6; color:#bfdbfe; border-radius:8px; padding:10px; margin-top:12px; }
      .error { color:#fca5a5; }
      .mode { margin:8px 0; font-size:0.95rem; }
      code.inline { background:#0b1220; padding:2px 6px; border-radius:6px; border:1px solid #334155; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Outils de fichiers (offline)</h1>
      <p class="note">Si Internet n’est pas dispo, le site utilise un format “Archive locale” à la place du vrai ZIP. Ça marche hors ligne pour compresser/décompresser ici.</p>
      <div id="envMode" class="mode"></div>

      <section>
        <h2>Compresser des fichiers</h2>
        <label for="zipFiles"><strong>Choisir des fichiers à compresser:</strong></label>
        <input type="file" id="zipFiles" multiple/>
        <button class="btn" id="makeZipBtn" type="button">Compresser et télécharger</button>
        <div id="zipStatus" class="card"></div>
      </section>

      <section>
        <h2>Décompresser une archive</h2>
        <label for="zipInput"><strong>Choisir un fichier d’archive:</strong></label>
        <input type="file" id="zipInput" accept=".zip,.json"/>
        <button class="btn" id="unzipBtn" type="button">Décompresser et afficher</button>
        <div id="unzipResult" class="card"></div>
        <p class="note">Le site reconnaît automatiquement une archive ZIP réelle (si JSZip dispo) ou une Archive locale (.zip ou .json) créée par ce site.</p>
      </section>

      <section>
        <h2>Téléverser une image protégée par mot de passe</h2>
        <label for="protImage"><strong>Choisir une image:</strong></label>
        <input type="file" id="protImage" accept="image/*"/>
        <label for="protPwd"><strong>Définir un mot de passe:</strong></label>
        <input type="password" id="protPwd" placeholder="Mot de passe"/>
        <button class="btn" id="saveProtBtn" type="button">Téléverser (local) et protéger</button>
        <div id="protStatus" class="card"></div>
        <div class="warn">Conserve l’ID d’accès et le mot de passe. Sans eux, tu ne pourras pas voir l’image.</div>
      </section>

      <section>
        <h2>Voir une image protégée</h2>
        <label for="viewId"><strong>Entrer l’ID d’accès:</strong></label>
        <input type="text" id="viewId" placeholder="ID affiché après le téléversement"/>
        <label for="viewPwd"><strong>Entrer le mot de passe:</strong></label>
        <input type="password" id="viewPwd" placeholder="Mot de passe"/>
        <button class="btn" id="viewBtn" type="button">Vérifier et afficher</button>
        <div id="viewResult" class="card"></div>
      </section>
    </div>

    <script>
      // Utils
      const $ = (id) => document.getElementById(id);
      const text = (el, msg) => { el.textContent = msg; };
      const html = (el, msg) => { el.innerHTML = msg; };
      const bufToHex = (buffer) => Array.from(new Uint8Array(buffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
      const randomId = () => ([1,2,3,4].map(() => Math.random().toString(36).slice(2)).join('-'));

      // Téléchargement blob (fallback si FileSaver indisponible)
      function saveBlob(blob, name) {
        try { if (typeof saveAs === 'function') return saveAs(blob, name); } catch(_) {}
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = name; a.style.display='none';
        document.body.appendChild(a); a.click();
        setTimeout(() => { URL.revokeObjectURL(url); document.body.removeChild(a); }, 500);
      }

      // Hachage du mot de passe (crypto.subtle ou fallback)
      async function hashPassword(pwd) {
        const enc = new TextEncoder();
        if (crypto && crypto.subtle) {
          try {
            const digest = await crypto.subtle.digest('SHA-256', enc.encode(pwd));
            return bufToHex(digest);
          } catch(_) {}
        }
        // Fallback simple (pour offline/preview; pas pour prod)
        let h = 0; for (let i=0;i<pwd.length;i++){ h=(h<<5)-h+pwd.charCodeAt(i); h|=0; }
        return 'fallback-'+Math.abs(h).toString(16);
      }

      // Détection du mode ZIP
      const hasJSZip = () => (typeof JSZip !== 'undefined');
      function updateEnvMode() {
        const parts = [];
        parts.push('Mode ZIP: ' + (hasJSZip() ? 'ZIP réel (JSZip)' : 'Archive locale (offline)'));
        parts.push('Téléchargement: ' + (typeof saveAs === 'function' ? 'FileSaver' : 'Lien direct'));
        parts.push('IndexedDB: ' + (('indexedDB' in window) ? 'disponible' : 'indisponible => localStorage'));
        parts.push('crypto.subtle: ' + ((crypto && crypto.subtle) ? 'disponible' : 'fallback'));
        $('envMode').innerHTML = parts.map(p => '<span>'+p+'</span>').join(' • ');
      }
      updateEnvMode();
      setTimeout(updateEnvMode, 1500); // après potentiel chargement CDN

      // Dépôt: IndexedDB si possible, sinon localStorage
      const DB_NAME = 'imagesProtegeesDB';
      const STORE_NAME = 'images';
      let db = null;
      let storageMode = 'indexeddb';

      function openDB() {
        return new Promise((resolve) => {
          if (!window.indexedDB) { storageMode = 'localstorage'; return resolve(null); }
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains(STORENAME)) d.createObjectStore(STORENAME, { keyPath: 'id' });
          };
          req.onsuccess = () => { db = req.result; resolve(db); };
          req.onerror = () => { storageMode = 'localstorage'; resolve(null); };
        });
      }

      function putImageIndexedDB(record) {
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readwrite');
          tx.objectStore(STORE_NAME).put(record);
          tx.oncomplete = () => resolve(true);
          tx.onerror = () => reject(tx.error);
        });
      }
      function getImageIndexedDB(id) {
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readonly');
          const req = tx.objectStore(STORE_NAME).get(id);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      }
      async function blobToDataURL(blob) {
        return new Promise((resolve,reject)=>{
          const fr=new FileReader(); fr.onload=()=>resolve(fr.result); fr.onerror=reject; fr.readAsDataURL(blob);
        });
      }
      async function putImage(record) {
        if (storageMode === 'indexeddb') return putImageIndexedDB(record);
        const dataURL = await blobToDataURL(record.blob);
        const payload = { id:record.id, name:record.name, mime:record.mime, dataURL, hash:record.hash };
        localStorage.setItem('img_'+record.id, JSON.stringify(payload));
        return true;
      }
      async function getImage(id) {
        if (storageMode === 'indexeddb') return getImageIndexedDB(id);
        const raw = localStorage.getItem('img_'+id);
        if (!raw) return null;
        const payload = JSON.parse(raw);
        const blob = await (await fetch(payload.dataURL)).blob();
        return { id:payload.id, name:payload.name, mime:payload.mime, blob, hash:payload.hash };
      }

      // Archive locale: empaqueter/dépaqueter sans JSZip (JSON + base64)
      async function fileToBase64(file) {
        return new Promise((resolve,reject)=>{
          const fr=new FileReader(); fr.onload=()=>resolve(fr.result.split(',')[1]); fr.onerror=reject; fr.readAsDataURL(file);
        });
      }
      function base64ToBlob(b64, mime) {
        const byteChars = atob(b64);
        const byteNums = new Array(byteChars.length);
        for (let i=0;i<byteChars.length;i++){ byteNums[i]=byteChars.charCodeAt(i); }
        const bytes = new Uint8Array(byteNums);
        return new Blob([bytes], { type: mime || 'application/octet-stream' });
      }
      async function buildLocalArchive(files) {
        const items = [];
        for (const f of files) {
          const b64 = await fileToBase64(f);
          items.push({ name: f.name, mime: f.type || 'application/octet-stream', data: b64 });
        }
        return JSON.stringify({ type: 'LOCALARCHIVEv1', createdAt: Date.now(), items });
      }
      async function parseLocalArchive(file) {
        const text = await file.text();
        const obj = JSON.parse(text);
        if (!obj || obj.type !== 'LOCALARCHIVEv1') throw new Error('Archive locale invalide');
        return obj.items.map(it => ({ name: it.name, blob: base64ToBlob(it.data, it.mime) }));
      }

      // Compression
      const zipFilesInput = $('zipFiles');
      const zipStatus = $('zipStatus');
      $('makeZipBtn').addEventListener('click', async () => {
        const files = zipFilesInput.files;
        if (!files || files.length === 0) { html(zipStatus, '<p>Aucun fichier sélectionné.</p>'); return; }
        html(zipStatus, '<p>Compression en cours...</p>');
        try {
          const name = 'archive-' + Date.now() + '.zip';
          if (hasJSZip()) {
            const zip = new JSZip();
            for (const file of files) zip.file(file.name, await file.arrayBuffer());
            const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
            saveBlob(blob, name);
            html(zipStatus, '<p>ZIP réel généré: <code class="inline">'+name+'</code></p>');
          } else {
            const json = await buildLocalArchive(files);
            const blob = new Blob([json], { type: 'application/json' });
            // On donne une extension .zip pour l’homogénéité, mais c’est une archive locale JSON
            saveBlob(blob, name);
            html(zipStatus, '<p>Archive locale générée: <code class="inline">'+name+'</code> (lisible ici hors ligne)</p>');
          }
        } catch (err) {
          console.error(err);
          html(zipStatus, '<p class="error">Erreur lors de la compression.</p>');
        }
      });

      // Décompression
      const unzipResult = $('unzipResult');
      $('unzipBtn').addEventListener('click', async () => {
        const file = $('zipInput').files && $('zipInput').files[0];
        if (!file) { html(unzipResult, '<p>Aucun fichier d’archive sélectionné.</p>'); return; }
        html(unzipResult, '<p>Décompression en cours...</p>');
        try {
          // Tenter ZIP réel si JSZip et si fichier binaire ressemble à zip
          const nameLower = (file.name || '').toLowerCase();
          const tryRealZip = hasJSZip();

          if (tryRealZip) {
            try {
              const ab = await file.arrayBuffer();
              const zip = await JSZip.loadAsync(ab);
              const list = document.createElement('ul');
              const entries = Object.values(zip.files);
              if (entries.length === 0) { html(unzipResult, '<p>Aucun fichier dans l’archive ZIP.</p>'); return; }
              for (const entry of entries) {
                if (entry.dir) continue;
                const blob = await entry.async('blob');
                const url = URL.createObjectURL(blob);
                const li = document.createElement('li');
                const a = document.createElement('a'); a.href = url; a.download = entry.name; a.textContent = entry.name+' (télécharger)';
                a.style.display='inline-block'; a.style.marginRight='10px';
                li.appendChild(a);
                if (/(\.png|\.jpg|\.jpeg|\.gif|\.webp|\.bmp|\.svg)$/i.test(entry.name)) {
                  const img = document.createElement('img'); img.src=url; img.alt=entry.name; img.style.maxWidth='300px'; img.style.display='block'; img.style.marginTop='6px';
                  li.appendChild(img);
                }
                list.appendChild(li);
              }
              unzipResult.innerHTML = ''; unzipResult.appendChild(list);
              return;
            } catch (e) {
              console.warn('Échec ZIP réel, bascule vers archive locale:', e);
            }
          }

          // Archive locale (JSON)
          try {
            const items = await parseLocalArchive(file);
            const list = document.createElement('ul');
            if (items.length === 0) { html(unzipResult, '<p>Aucun fichier dans l’archive locale.</p>'); return; }
            for (const it of items) {
              const url = URL.createObjectURL(it.blob);
              const li = document.createElement('li');
              const a = document.createElement('a'); a.href = url; a.download = it.name; a.textContent = it.name+' (télécharger)';
              a.style.display='inline-block'; a.style.marginRight='10px';
              li.appendChild(a);
              if (/(\.png|\.jpg|\.jpeg|\.gif|\.webp|\.bmp|\.svg)$/i.test(it.name)) {
                const img = document.createElement('img'); img.src=url; img.alt=it.name; img.style.maxWidth='300px'; img.style.display='block'; img.style.marginTop='6px';
                li.appendChild(img);
              }
              list.appendChild(li);
            }
            unzipResult.innerHTML = ''; unzipResult.appendChild(list);
          } catch (err2) {
            console.error(err2);
            html(unzipResult, '<p class="error">Archive non reconnue. Si hors ligne, utilise une archive créée par ce site.</p>');
          }
        } catch (err) {
          console.error(err);
          html(unzipResult, '<p class="error">Erreur lors de la décompression.</p>');
        }
      });

      // Images protégées
      (async () => { await openDB(); })();

      $('saveProtBtn').addEventListener('click', async () => {
        const file = $('protImage').files && $('protImage').files[0];
        const pwd = $('protPwd').value || '';
        if (!file || !pwd) { html($('protStatus'), '<p>Image et mot de passe sont obligatoires.</p>'); return; }
        html($('protStatus'), '<p>Enregistrement local en cours...</p>');
        try {
          const id = randomId();
          const hash = await hashPassword(pwd);
          const blob = await file.slice(0, file.size, file.type || 'application/octet-stream');
          await putImage({ id, name: file.name, mime: file.type || 'application/octet-stream', blob, hash });
          html($('protStatus'), `
            <p>Image protégée créée.</p>
            <p><strong>ID d’accès:</strong></p>
            <div class="id-box">${id}</div>
            <p class="note">Copie l’ID et garde ton mot de passe. Ils sont nécessaires pour l’accès.</p>
          `);
          $('protImage').value = ''; $('protPwd').value = '';
        } catch (err) {
          console.error(err);
          html($('protStatus'), '<p class="error">Erreur lors de l’enregistrement.</p>');
        }
      });

      $('viewBtn').addEventListener('click', async () => {
        const id = ($('viewId').value || '').trim();
        const pwd = $('viewPwd').value || '';
        if (!id || !pwd) { html($('viewResult'), '<p>ID et mot de passe sont requis.</p>'); return; }
        html($('viewResult'), '<p>Vérification...</p>');
        try {
          const rec = await getImage(id);
          if (!rec) { html($('viewResult'), '<p>Ressource protégée introuvable.</p>'); return; }
          const hash = await hashPassword(pwd);
          if (hash !== rec.hash) { html($('viewResult'), '<p>Mot de passe incorrect.</p>'); return; }
          const url = URL.createObjectURL(rec.blob);
          const isImage = /^image\//.test(rec.mime);
          const nameSafe = rec.name || 'image';
          html($('viewResult'), `
            <p><strong>Nom:</strong> ${nameSafe}</p>
            ${isImage ? <img src="${url}" alt="Image protégée"/> : '<p>Ce fichier n’est pas une image.</p>'}
            <p><a class="btn" href="${url}" download="${nameSafe}">Télécharger</a></p>
          `);
        } catch (err) {
          console.error(err);
          html($('viewResult'), '<p class="error">Erreur lors de l’accès.</p>');
        }
      });
    </script>
  </body>
</html>
